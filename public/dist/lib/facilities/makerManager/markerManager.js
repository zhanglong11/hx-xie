class Box{constructor(e,t,i,s){this.x=e,this.y=t,this.width=i,this.height=s}getSpace(){return this.width*this.height}}class SpaceManager{constructor(e,t){this.boxes=[],this.spaces=[new Box(0,0,e,t)]}isSpaceToPlace(e,t){return this._findMininmumFindSpaceIndex(e,t)<this.spaces.length}addBox(e,t){if(this.isSpaceToPlace(e,t)){let i=this._findMininmumFindSpaceIndex(e,t),s=this.spaces[i];return this._splitSpaceAt(i,e,t),{result:!0,box:{x:s.x,y:s.y,width:e,height:t}}}return{result:!1,box:null}}releaseBox(e,t,i,s){this.spaces.push(new Box(e,t,i,s)),this._reorderSpace()}_findMininmumFindSpaceIndex(e,t){let i=e*t,s=0,r=this.spaces.length;for(;s<r&&(this.spaces[s].getSpace()<i||this.spaces[s].width<e||this.spaces[s].height<t);)s++;return s}_splitSpaceAt(e,t,i){let s=this.spaces.splice(e,1)[0],r=[];s.width>t&&r.push(new Box(s.x+t,s.y,s.width-t,i)),s.height>i&&r.push(new Box(s.x,s.y+i,t,s.height-i)),s.width>t&&s.height>i&&r.push(new Box(s.x+t,s.y+i,s.width-t,s.height-i)),this.spaces=[...this.spaces,...r]}_reorderSpace(){this.spaces.sort((e,t)=>e.getSpace()-t.getSpace())}}function ceilPowerOfTwo(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))}function floorPowerOfTwo(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}class EntityTexture{constructor(e){this._texUrl=e,this.texture=THREE.ImageUtils.loadTexture(e),this.texture.flipY=!1}bindToMesh(e){this._belongTo=e}refresh(e){this.texture=THREE.ImageUtils.loadTexture(e),this.texture.flipY=!1,this._belongTo&&(this._belongTo.material.map=this.texture,this._belongTo.material.needsUpdate=!0)}}class LabelTextureManager{constructor(e,t=14,i=24,s=6,r=4){e=floorPowerOfTwo(e),this._texSideLength=e,this._padding=s,this._fontSize=t,this._lineHeight=i,this._borderRadius=r,this._textures={};let a=document.createElement("canvas");a.width=a.height=e,this.canvas=[a],this.spaceManagers=[new SpaceManager(e,e)]}_createNewCanvas(){const e=document.createElement("canvas");e.width=e.height=this._texSideLength;const t=new SpaceManager(this._texSideLength,this._texSideLength);this.canvas.push(e),this.spaceManagers.push(t)}_findApproprateCanvas(e,t){let i=0,s=this.canvas.length;for(;i<s;i++){let s=this.canvas[i].getContext("2d");s.save(),s.font=`${t}px Arial`;let{width:r}=s.measureText(e);if(s.restore(),this.spaceManagers[i].isSpaceToPlace(Math.ceil(r)+2*this._padding,this._lineHeight+2*this._padding))return i}return this._createNewCanvas(),i}_drawLabelToCanvas(e,t,i,s,r,a,n){n.save(),n.font=`${t}px Arial`,n.textAlign="center",n.textBaseline="middle",n.fillStyle="#ff0000",n.fillText(e,i+r/2,s+a/2),n.restore()}createLabelTexture(e,t){if(this._textures[e]){let t=this._textures[e];return{textureUrl:this.canvas[t.canvasIndex].toDataURL(),textureUvs:t.textureUvs,width:t.drawInfo.width,height:t.drawInfo.height}}t=4*(t||this._fontSize);let i=this._findApproprateCanvas(e,t),s=this.spaceManagers[i],r=this.canvas[i],a=r.getContext("2d");a.save(),a.font=`${t}px Arial`;let{width:n}=a.measureText(e);a.restore();let h=Math.ceil(n+2*this._padding),o=t+2*this._padding,{result:l,box:{x:c,y:d,height:u,width:p}}=s.addBox(h,o);if(!l)throw"Can not add new box to canvas: "+i;this._drawLabelToCanvas(e,t,c,d,h,o,a);let v=r.toDataURL(),g=[[c,d],[c+h,d],[c+h,d+o],[c,d+o]].reverse().reduce((e,t)=>{const[i,s]=t;return[...e,i/this._texSideLength,s/this._texSideLength]},[]);return p/=4,u/=4,this._textures[e]={canvasIndex:i,textureUvs:g,drawInfo:{x:c,y:d,width:p,height:u}},{textureUrl:v,textureUvs:g,width:p,height:u}}switchTextTo(e,t){if(this._textures[e]){let t=this._textures[e],{x:i,y:s,width:r,height:a}=t.drawInfo;this.spaceManagers[t.canvasIndex].releaseBox(i,s,r,a),delete this._textures[e]}return this.createLabelTexture(t)}}class IconTextureManager{constructor(e=512){this._canvasSideLength=e,this._spaceManger=new SpaceManager(e,e),this._canvas=document.createElement("canvas"),this._canvas.width=this._canvas.height=e,this._definedIcons={}}defineIcon(e,t){return this._definedIcons[e]?Promise.resolve(this._definedIcons[e]):new Promise("string"==typeof t?(i,s)=>{let r=new Image;r.onload=()=>{let{result:t,box:{x:a,y:n,width:h,height:o}}=this._spaceManger.addBox(r.width,r.height);t||s(new Error("Do not have enough space")),this._canvas.getContext("2d").drawImage(r,a,n);let l=this._canvas.toDataURL(),c=[[a,n],[a+h,n],[a+h,n+o],[a,n+o]].reverse().reduce((e,t)=>{const[i,s]=t;return[...e,i/this._canvasSideLength,s/this._canvasSideLength]},[]),d=new EntityTexture(l);this._definedIcons[e]={width:r.width,height:r.height,texture:d,textureUvs:c},i(this._definedIcons[e])},r.onerror=()=>{s(new Error("image load failure error"))},r.crossOrigin=!0,r.src=t}:i=>{let{result:s,box:{x:r,y:a,width:n,height:h}}=this._spaceManger.addBox(t.width,t.height);s||reject(new Error("Do not have enough space")),this._canvas.getContext("2d").drawImage(t,r,a);let o=this._canvas.toDataURL(),l=[[r,a],[r+n,a],[r+n,a+h],[r,a+h]].reverse().reduce((e,t)=>{const[i,s]=t;return[...e,i/this._canvasSideLength-1,s/this._canvasSideLength-1]},[]),c=new EntityTexture(o);c.flipY=!1,this._definedIcons[e]={width:t.width,height:t.height,texture:c,textureUvs:l},i(this._definedIcons[e])})}getIconTexture(e){return this._definedIcons[e]}isIconsDefined(e){return Array.isArray(e)||(e=[e]),e.every(e=>!!this._definedIcons[e])}}const entityVertexShader="\n    uniform vec2 uViewport;\n    uniform vec2 uEntitySize;\n    uniform vec3 uEntityPosition;\n    uniform mat4 uRotation;\n    uniform mat4 uProjectionMatrix;    \n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        vec4 pointPos = uRotation * vec4(position, 1.0);\n        vec4 pointPos2 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        vec4 pos = projectionMatrix * modelViewMatrix  * vec4(uEntityPosition , 1.0);\n        //gl_Position = vec4(pointPos.xy, pointPos2.z, 1.0) + vec4(pos.xy, 0.0, 0.0);\n        // gl_Position = uProjectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n",entityFragmentShader="\n    uniform sampler2D uMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(uMap, vUv);\n    }\n";class Entity{constructor(e,t,i,s,r,a){this.id=e,this.position=t,this.texture=a,this.width=i,this.height=s,this.viewport=new THREE.Vector2(0,0),this.material=new THREE.ShaderMaterial({uniforms:{uMap:{type:"t",value:a.texture},uViewport:{type:"v2",value:this.viewport},uEntitySize:{type:"v2",value:new THREE.Vector2(this.width,this.height)},uEntityPosition:{type:"v3",value:this.position},uRotation:{type:"m4",value:new THREE.Matrix4},uProjectionMatrix:{type:"m4",value:new THREE.Matrix4}},vertexShader:entityVertexShader,fragmentShader:entityFragmentShader,transparent:!0,side:THREE.DoubleSide,depthWrite:!1,depthTest:!0}),this.width=a.width,this.height=a.height,this.geo=createMarkerGeo(i,s,r),this.mesh=new THREE.Mesh(this.geo,this.material),"function"==typeof a.bindToMesh&&a.bindToMesh(this.mesh)}setPosition(e,t,i){this.position.set(e,t,i),this.material.needsUpdate=!0}setTexture(e){let t=new EntityTexture(e.textureUrl);this.material.uniforms.uMap.value=t.texturecdc,this.material.needsUpdate=!0;let i=createMarkerGeo(e.width,e.height,e.textureUvs);this.geo.attributes.position.set(i.attributes.position.array),this.geo.attributes.position.needsUpdate=!0,this.geo.attributes.index.set(i.attributes.index.array),this.geo.attributes.index.needsUpdate=!0,this.geo.attributes.uv.set(i.attributes.uv.array),this.geo.attributes.uv.needsUpdate=!0,this.geo.needsUpdate=!0}setViewport(e,t){this.viewport.set(e,t)}setRotation(e){let t=new THREE.Matrix4;t.makeRotationFromEuler(e),this.material.uniforms.uRotation.value=t,this.material.needsUpdate=!0}_setProjectionMatrix(e){this.material.uniforms.uProjectionMatrix.value=e,this.material.uniforms.needsUpdate=!0}}class EntityMananger{constructor(){this.entities=[]}addEntity(e){this.entities.push(e)}}function createMarkerGeo(e,t,i){let s=new THREE.BufferGeometry,r=new Float32Array([0,0,0,e,0,0,e,t,0,0,t,0]),a=new Uint16Array([3,0,1,3,1,2]);return s.addAttribute("position",new THREE.BufferAttribute(r,3)),s.addAttribute("index",new THREE.BufferAttribute(a,1)),s.addAttribute("uv",new THREE.BufferAttribute(new Float32Array(i),2)),s}const labelTextureManager=new LabelTextureManager(1024);export const iconTextureManager=new IconTextureManager(1024);class Marker{constructor(e,t,i,s,r,a,n){this.id=e,this.type=t,this.isHide=!1,this.label=i,this._size=r,this._labelShrink=n;let h=labelTextureManager.createLabelTexture(i,a);this.labelTexInfo=h;let o=new EntityTexture(h.textureUrl);this._label=new Entity(`${e}_label`,new THREE.Vector3(0,0,0),h.width/n,h.height/n,h.textureUvs,o);let l=iconTextureManager.getIconTexture(t);this._icon=new Entity(`${e}_icon`,new THREE.Vector3(0,0,0),r.width,r.height,l.textureUvs,l.texture),this._label.id=this._icon.id=e,this._label.mesh.userData.id=e,this._icon.mesh.userData.id=e,this._marker=new THREE.Object3D,this._marker.add(this._label.mesh),this._marker.add(this._icon.mesh),this._label.mesh.position.set(r.width,r.height/2-h.height/n/2,0),this._marker.position.set(s.x,s.y,s.z)}setPosition(e){this._marker.position.set(e.x,e.y,e.z)}setLabel(e){let t=labelTextureManager.switchTextTo(this.label,e);this.label=e,this._label.setTexture(t)}_setSelfProjectionMatrix(e){this._label._setProjectionMatrix(e),this._icon._setProjectionMatrix(e)}setScale(e){this._marker.scale.set(e,e,1),this._icon.mesh.scale.set(e,e,1),this._label.mesh.scale.set(e,e,1),this._label.mesh.position.set(this._size.width*e,(this._size.height/2-this.labelTexInfo.height/this._labelShrink/2)*e,0)}}class EventEmitter{constructor(){this._callbacks={}}on(e,t,i=t){this._callbacks[e]||(this._callbacks[e]=[]),this._callbacks[e].push({fn:t,thisArg:i})}emit(e,...t){if(this._callbacks[e])for(let i of this._callbacks[e])i.fn.call(i.thisArg,...t)}off(e,t){let i=this._callbacks[e];if(i)return;let s=i.findIndex(e=>e.fn===t);i.split(s,1)}}export class MarkerManager extends EventEmitter{constructor(e,t={width:10,height:10},i=12){super(),this.markerMap={},this._hidedMarkers={},this.viewer=e,this._mouse=new THREE.Vector2,this._raycaster=new THREE.Raycaster,this._defaultSize=t,this._defaultFontsize=i,this._overlayCreated=!1,this._projectionMatrix=null,this._scale=1,e.addEventListener(Bimfish.Viewing.CAMERA_CHANGE_EVENT,this._handleCameraChange),e.addEventListener(Bimfish.Viewing.Private.Prefs.REVERSE_MOUSE_ZOOM_DIR,e=>{console.log("zoom dir: ",e)}),e.impl.canvas.addEventListener("click",this._handleMouseClick)}_getMotionScale(e,t,i){if(!this.viewer.navigation.isActionEnabled("zoom")||Math.abs(e)<=this.viewer.navigation.__kEpsilon)return 1;var s=this.viewer.navigation.getPosition(),r=this.viewer.navigation.getEyeVector();if(!this.viewer.navigation.getCamera().isPerspective){var a=r.lengthSq(),n=r.dot(this.viewer.navigation.getTarget().sub(t));t=r.clone().multiplyScalar(n/a).add(t)}var h=t.clone().sub(s).length(),o=h+e;o<this.__minDistance&&(o=this.__minDistance);var l=o/h;return l=this.viewer.navigation.applyDollyConstraint(l,i)}_handleCameraChange=e=>{let t=e.camera,i=(t.rotation,e.camera.matrix),s=(t.position,this.viewer.toolController.getTool("dolly")),r=s.getDollyScrollScale();const a=new THREE.Vector3;s.getMotionDelta(a);let n=a.z*r,h=this.viewer.navigation.getPivotPoint(),o=this._getMotionScale(n*s.getDollySpeed(h),h,this.viewer.impl.getFitBounds());this._scale*=o;for(let e in this.markerMap){let t=this.markerMap[e];t._marker.setRotationFromMatrix(i),t.setScale(this._scale)}};_handleMouseClick=e=>{let t=e.target,i=this.viewer.impl.camera,s=this._raycaster,{left:r,top:a}=t.getBoundingClientRect(),{clientX:n,clientY:h}=e,o=n-r,l=h-a;const c=new THREE.Vector3,d=new THREE.Vector3;i.isPerspective?(c.set(o/t.width*2-1,1-l/t.height*2,.5),c.unproject(i),s.set(i.position,c.sub(i.position).normalize())):(c.set(o/t.width*2-1,1-l/t.height*2,-1),c.unproject(i),d.set(0,0,-1),s.set(c,d.transformDirection(i.matrixWorld)));let u=Object.keys(this.markerMap).reduce((e,t)=>{let i=this.markerMap[t],s=i._label.mesh;return[...e,i._icon.mesh,s]},[]);var p=this._raycaster.intersectObjects(u,!0);p[0]&&(console.log("select",{canvasPos:{x:o,y:l},id:p[0].object.userData.id}),this.emit("select",{canvasPos:{x:o,y:l},id:p[0].object.userData.id}))};addMarker(e,t,i,s,r,a,n){this._overlayCreated||this.viewer.impl.createOverlayScene("markers",null,null,this.viewer.impl.camera);let h=new Marker(e,t,i,s,r,a,n);this.markerMap[e]=h;let o=this.viewer.impl.camera.rotation;h._marker.setRotationFromMatrix(this.viewer.impl.camera.matrix),h.setScale(this._scale),h._label.setRotation(o),h._icon.setRotation(o),this.viewer.impl.addOverlay("markers",h._marker),setTimeout(()=>this.viewer.impl.invalidate(!1,!1,!0))}addMarkerWithDefaultSize(e,t,i,s){this.addMarker(e,t,i,s,this._defaultSize,this._defaultFontsize,1)}removeMarker(e){let t=this.markerMap[e];return!!t&&(this.viewer.impl.removeOverlay("markers",t._marker),delete this.markerMap[e],!0)}removeAllMarkers(){let e=Object.keys(this.markerMap);for(let t of e){let e=this.markerMap[t];this.viewer.impl.removeOverlay("markers",e._marker)}return this.markerMap={},!0}showMarker(e){let t=this._hidedMarkers[e];return!!t&&(this.viewer.impl.addOverlay("markers",t._marker),delete this._hidedMarkers[e],setTimeout(()=>this.viewer.impl.invalidate(!1,!1,!0)),!0)}showAllMarkers(){let e=Object.keys(this._hidedMarkers);for(let t of e){this._hidedMarkers[t];this.viewer.impl.addOverlay("markers",hidedMarker._marker)}setTimeout(()=>this.viewer.impl.invalidate(!1,!1,!0)),this._hidedMarkers={}}hideMarker(e){if(this._hidedMarkers[e])return!0;let t=this.markerMap[e];return!!t&&(this._hidedMarkers[e]=t,this.viewer.impl.removeOverlay("markers",t._marker),!0)}hideAllMarkers(){let e=Object.keys(this.markerMap);for(let t of e)this.hideMarker(t)}setMarkerText(e,t){let i=this.markerMap[e];return!!i&&i.setLabel(t)}}